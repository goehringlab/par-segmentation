:py:mod:`par_segmentation`
==========================

.. py:module:: par_segmentation


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   _interactive/index.rst
   _legacy/index.rst
   _model/index.rst
   _tgf_interpolate/index.rst
   funcs/index.rst
   quantifier/index.rst
   roi/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   par_segmentation._FitPlotter
   par_segmentation.ImageQuantGradientDescent
   par_segmentation.ImageQuantDifferentialEvolutionSingle
   par_segmentation.ImageQuantDifferentialEvolutionMulti
   par_segmentation.ImageQuantGradientDescent
   par_segmentation.ImageQuantDifferentialEvolutionMulti
   par_segmentation.ImageQuant
   par_segmentation._ROI
   par_segmentation.ROI_jupyter



Functions
~~~~~~~~~

.. autoapisummary::

   par_segmentation.offset_coordinates
   par_segmentation.load_image
   par_segmentation.save_img
   par_segmentation.save_img_jpeg
   par_segmentation.straighten
   par_segmentation.rotated_embryo
   par_segmentation.rotate_roi
   par_segmentation.norm_roi
   par_segmentation.interp_1d_array
   par_segmentation.interp_2d_array
   par_segmentation.rolling_ave_1d
   par_segmentation.rolling_ave_2d
   par_segmentation.bounded_mean_1d
   par_segmentation.bounded_mean_2d
   par_segmentation.asi
   par_segmentation.dosage
   par_segmentation.make_mask
   par_segmentation.readnd
   par_segmentation.organise_by_nd
   par_segmentation._direcslist
   par_segmentation.direcslist
   par_segmentation.in_notebook
   par_segmentation.in_notebook
   par_segmentation.view_stack_tk
   par_segmentation.view_stack_jupyter
   par_segmentation.view_stack
   par_segmentation.plot_segmentation
   par_segmentation.plot_segmentation_jupyter
   par_segmentation.plot_quantification
   par_segmentation.plot_quantification_jupyter
   par_segmentation.plot_fits
   par_segmentation.plot_fits_jupyter
   par_segmentation.straighten
   par_segmentation.rolling_ave_2d
   par_segmentation.interp_1d_array
   par_segmentation.interp_2d_array
   par_segmentation.rotate_roi
   par_segmentation.offset_coordinates
   par_segmentation.interp_roi
   par_segmentation.interpolate
   par_segmentation.create_offsets_spline
   par_segmentation.straighten
   par_segmentation.rolling_ave_2d
   par_segmentation.interp_1d_array
   par_segmentation.interp_2d_array
   par_segmentation.rotate_roi
   par_segmentation.interp_roi
   par_segmentation.offset_coordinates
   par_segmentation.spline_roi
   par_segmentation.gaus
   par_segmentation.error_func
   par_segmentation.polycrop
   par_segmentation.bg_subtraction
   par_segmentation.calc_vol
   par_segmentation.calc_sa
   par_segmentation.save_img
   par_segmentation.in_notebook
   par_segmentation.view_stack
   par_segmentation.view_stack_jupyter
   par_segmentation.plot_fits
   par_segmentation.plot_fits_jupyter
   par_segmentation.plot_segmentation
   par_segmentation.plot_segmentation_jupyter
   par_segmentation.plot_quantification
   par_segmentation.plot_quantification_jupyter
   par_segmentation.def_roi
   par_segmentation.spline_roi
   par_segmentation.interp_roi
   par_segmentation.offset_coordinates



.. py:function:: offset_coordinates(roi: numpy.ndarray, offsets: Union[numpy.ndarray, float], periodic: bool = True) -> numpy.ndarray

   Reads in coordinates, adjusts according to offsets

   Args:
       roi:  two column array containing x and y coordinates. e.g. roi = np.loadtxt(filename)
       offsets: array the same length as coors. Direction?
       periodic: set to True if the ROI is periodic

   Returns:
        array in same format as coors containing new coordinates.

        To save this in a fiji readable format:
        np.savetxt(filename, newcoors, fmt='%.4f', delimiter=' ')



.. py:function:: load_image(filename: str) -> numpy.ndarray

   Given the filename of a TIFF, creates numpy array with pixel intensities

   Args:
       filename: full path to the file to import (including extension)

   Returns:
       A numpy array of the image



.. py:function:: save_img(img: numpy.ndarray, direc: str)

   Saves 2D array as .tif file

   Args:
       img: numpy array of the image to save
       direc: file path to save to (including '.tif' extension)



.. py:function:: save_img_jpeg(img: numpy.ndarray, direc: str, cmin: Optional[float] = None, cmax: Optional[float] = None, cmap: str = 'gray')

   Saves 2D array as jpeg, according to min and max pixel intensities

   Args:
       img: numpy array of the image to save
       direc: file path to save to (including '.jpeg' extension)
       cmin: optional, sets intensity scaling (along with cmax)
       cmax: optional, sets intensity scaling (along with cmin)
       cmap: colour map (use string corresponding to matplotlib colormap)



.. py:function:: straighten(img: numpy.ndarray, roi: numpy.ndarray, thickness: int, periodic: bool = True, interp: str = 'cubic', ninterp: Optional[int] = None) -> numpy.ndarray

   Creates straightened image based on coordinates
   Todo: Doesn't work properly for non-periodic rois

   Args:
       img: numpy array of image to straighten
       roi: coordinates of roi (two column array with x and y coordinates), should be 1 pixel length apart in a loop
       thickness: thickness (pixel units) of the region surrounding the ROI to straighten
       periodic: set to True is the ROI is periodic (a full loop)
       interp: interpolation type, 'cubic' or 'linear
       ninterp: optional. If specified, interpolation along the y axis of the straight image will be at this many
       evenly spaced points. If not specified, interpolation will be performed at pixel-width distances.

   Returns:
       Straightened image as 2D numpy array. Will have dimensions [thickness, roi.shape[0]] unless ninterp is
       specified, in which case [ninterp, roi.shape[0]]



.. py:function:: rotated_embryo(img: numpy.ndarray, roi: numpy.ndarray, l: int, h: int, order: int = 1, return_roi: bool = False) -> Union[numpy.ndarray, Tuple[numpy.array, numpy.array]]

   Takes an image and rotates according to coordinates so that anterior is on left, posterior on right
   Todo: some of the returned coordinates are anticlockwise

   Args:
       img: numpy array of image to rotate
       roi: roi of cell boundary (two columns specifying x and y coordinates)
       l: length of output image (pixel units)
       h: height of output image (pixel units)
       order: interpolation order. 1 or 3 for linear or cubic interpolation
       return_roi: if True, will return roi corresponding to the cell edge in the new image

   Returns:
       numpy array of rotated image with dimensions [h, l]
       if return_roi is True, will also return roi corresponding to the cell edge in the new image



.. py:function:: rotate_roi(roi: numpy.ndarray) -> numpy.ndarray

   Rotates coordinate array so that most posterior point is at the beginning

   Args:
       roi: two column numpy array of coordinates to rotate

   Returns:
       numpy array of same shape as roi with rotated coordinates



.. py:function:: norm_roi(roi: numpy.ndarray)

   Aligns coordinates to their long axis

   Args:
       roi: two column numpy array of coordinates to normalise

   Returns:
       numpy array of same shape as roi with normalised coordinates



.. py:function:: interp_1d_array(array: numpy.ndarray, n: int, method: str = 'cubic') -> numpy.ndarray

   Interpolates a one dimensional array into n points

   Args:
       array: one dimensional numpy array
       n: number of points to evaluate. Will evaluate this many points at evenly space intervals along the length of
       array
       method: 'linear' or 'cubic'

   Returns:
       interpolated array (one dimensional array of length n)



.. py:function:: interp_2d_array(array: numpy.ndarray, n: int, ax: int = 0, method: str = 'cubic') -> numpy.ndarray

   Interpolates a two dimensional array along one axis into n points

   Args:
       array: two dimensional numpy array
       n: number of points to evaluate along the specified axis
       ax: 0 or 1, specifies the axis to interpolate along. 0 corresponds to the rows and 1 corresponds to the columns.
       method: 'linear' or 'cubic'

   Returns:
       Interpolated array. 2D array of shape [array.shape[0], n] if ax==1, or [n, array.shape[1] if ax==0



.. py:function:: rolling_ave_1d(array: numpy.ndarray, window: int, periodic: bool = True) -> numpy.ndarray

   Performs a rolling window average along a one dimensional array

   Args:
       array: one dimensional array
       window: rolling average window size. The function will compute the average of `window` consecutive elements at a
           time.
       periodic: specifies if array is periodic. If true, averaging rolls over at ends. If false, the function will not
           average over the elements at the ends of the array.

   Returns:
       numpy array same size as input array, containing the rolling average of the input array.



.. py:function:: rolling_ave_2d(array: numpy.ndarray, window: int, periodic: bool = True) -> numpy.ndarray

   Returns rolling average across the x axis of a 2D array

   Args:
       array: two dimensional array
       window: rolling average window size
       periodic: specifies if array is periodic. If true, averaging rolls over at ends

   Returns:
       numpy array same size as input array



.. py:function:: bounded_mean_1d(array: numpy.ndarray, bounds: tuple, weights: Optional[numpy.ndarray] = None) -> float

   Averages 1D array over region specified by bounds
   Array and weights should be same length
   Todo: Should add interpolation step first?
   Todo: combine with 2d function

   Args:
       array: one dimensional numpy array
       bounds: specifies window to average over. (min, max) from 0 to 1 specifying start and end of the array
       weights: if weights are specified a weighted average will be performed

   Returns:
       single number corresponding to mean value over the bounds specified



.. py:function:: bounded_mean_2d(array: numpy.ndarray, bounds: tuple) -> numpy.ndarray

   Averages 2D array in y dimension over region specified by bounds
   Todo: Should add axis parameter
   Todo: Should add interpolation step first

   Args:
       array: two dimensional numpy array
       bounds: specifies window to average over. (min, max) from 0 to 1 specifying start and end of the array

   Returns:
       one dimensional numpy array of length array.shape[0], corresponding to mean value over the bounds specified



.. py:function:: asi(mems: numpy.ndarray, size: float) -> float

   Calculates asymmetry index based on membrane concentration profile

   Args:
       mems: numpy array of membrane concentration values. Periodic array starting from extreme posterior
       size: size of region to average over when calculating anterior and posterior concentrations (from 0 to 1, where 1 indicates the whole embryo)

   Returns:
       asymmetry index



.. py:function:: dosage(img: numpy.ndarray, roi: numpy.ndarray, expand: float) -> numpy.ndarray

   One way of calculating protein dosage from an image

   Args:
       img: image 2D numpy array
       roi: roi representing cell edge (two-column numpy array)
       expand: expand the ROI by this many pixels before calculating the dosage

   Returns:
       dosage



.. py:function:: make_mask(shape: tuple, roi: numpy.ndarray) -> numpy.ndarray

   Create a mask for an image based on an ROI

   Args:
       shape: shape of the binary mask
       roi: roi of the mask region

   Returns:
       binary mask 



.. py:function:: readnd(path: str) -> dict

   Read an nd file

   Args:
       path: directory to embryo folder containing nd file

   Returns:
       dictionary containing data from nd file



.. py:function:: organise_by_nd(path: str)

   Organises images in a folder using the nd files

   Args:
       path: path to folder containing nd files



.. py:function:: _direcslist(dest: str, levels: int = 0, exclude: Optional[tuple] = ('!', ), exclusive: Optional[tuple] = None) -> list


.. py:function:: direcslist(dest: str, levels: int = 0, exclude: Optional[tuple] = ('!', ), exclusive: Optional[tuple] = None) -> list

   Gives a list of directories within a given directory (full path)
   Todo: os.walk

   Args:
       dest: path of parent directory
       levels: number of levels to go down. E.g. if 0, only return folders within the parent folder; if 1, return
       folders within folders within the parent folder
       exclude: exclude directories containing any strings within this tuple
       exclusive: exclude directories that don't contain all the strings within this tuple

   Returns:
       list of directories



.. py:function:: in_notebook()

   Tests whether python is being run within a notebook

   https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook



.. py:function:: in_notebook()

   Tests whether python is being run within a notebook

   https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook



.. py:function:: view_stack_tk(frames: Union[list, numpy.ndarray], start_frame: int = 0, end_frame: Optional[int] = None, show: bool = True)

   Interactive stack viewer

   Args:
       frames: either a numpy array of a 2D image or a list of 2D arrays
       start_frame: optional. If speficied only show frames after this index
       end_frame: optional. If specified only show frames before this index
       show: if True, show the image

   Returns:
       figure and axis



.. py:function:: view_stack_jupyter(frames: Union[list, numpy.ndarray], start_frame: int = 0, end_frame: Optional[int] = None)


.. py:function:: view_stack(frames: Union[list, numpy.ndarray], start_frame: int = 0, end_frame: Optional[int] = None)


.. py:function:: plot_segmentation(frames: Union[list, numpy.ndarray], rois: Union[list, numpy.ndarray])

   Plot segmentation results

   Args:
       frames: either a numpy array of a 2D image or a list of 2D arrays
       rois: either a single two-column numpy array of ROI coordinates or a list of arrays

   Returns:
       figure and axis



.. py:function:: plot_segmentation_jupyter(frames: Union[list, numpy.ndarray], rois: Union[list, numpy.ndarray])

   Plot segmentation results - use this function in a jupyter notebook environment

   Args:
       frames: either a numpy array of a 2D image or a list of 2D arrays
       rois: either a single two-column numpy array of ROI coordinates or a list of arrays

   Returns:
       figure and axis



.. py:function:: plot_quantification(mems: Union[list, numpy.ndarray])

   Plot quantification results

   Args:
       mems: either a numpy array of membrane concentrations for one image or a list of arrays for multiple images

   Returns:
       figure and axis



.. py:function:: plot_quantification_jupyter(mems: Union[list, numpy.ndarray])

   Plot quantification results - use this function in a jupyter notebook environment

   Args:
       mems: either a numpy array of membrane concentrations for one image or a list of arrays for multiple images

   Returns:
       figure and axis



.. py:class:: _FitPlotter(target: Union[list, numpy.ndarray], fit: Union[list, numpy.ndarray])


   .. py:method:: update_pos(p: float)


   .. py:method:: update_frame(i: int)


   .. py:method:: ax1_update()


   .. py:method:: ax2_update()



.. py:function:: plot_fits(target: Union[list, numpy.ndarray], fit_total: Union[list, numpy.ndarray])


.. py:function:: plot_fits_jupyter(target: Union[list, numpy.ndarray], fit: Union[list, numpy.ndarray])


.. py:function:: straighten(img: numpy.ndarray, roi: numpy.ndarray, thickness: int, periodic: bool = True, interp: str = 'cubic', ninterp: Optional[int] = None) -> numpy.ndarray

   Creates straightened image based on coordinates
   Todo: Doesn't work properly for non-periodic rois

   Args:
       img: numpy array of image to straighten
       roi: coordinates of roi (two column array with x and y coordinates), should be 1 pixel length apart in a loop
       thickness: thickness (pixel units) of the region surrounding the ROI to straighten
       periodic: set to True is the ROI is periodic (a full loop)
       interp: interpolation type, 'cubic' or 'linear
       ninterp: optional. If specified, interpolation along the y axis of the straight image will be at this many
       evenly spaced points. If not specified, interpolation will be performed at pixel-width distances.

   Returns:
       Straightened image as 2D numpy array. Will have dimensions [thickness, roi.shape[0]] unless ninterp is
       specified, in which case [ninterp, roi.shape[0]]



.. py:function:: rolling_ave_2d(array: numpy.ndarray, window: int, periodic: bool = True) -> numpy.ndarray

   Returns rolling average across the x axis of a 2D array

   Args:
       array: two dimensional array
       window: rolling average window size
       periodic: specifies if array is periodic. If true, averaging rolls over at ends

   Returns:
       numpy array same size as input array



.. py:function:: interp_1d_array(array: numpy.ndarray, n: int, method: str = 'cubic') -> numpy.ndarray

   Interpolates a one dimensional array into n points

   Args:
       array: one dimensional numpy array
       n: number of points to evaluate. Will evaluate this many points at evenly space intervals along the length of
       array
       method: 'linear' or 'cubic'

   Returns:
       interpolated array (one dimensional array of length n)



.. py:function:: interp_2d_array(array: numpy.ndarray, n: int, ax: int = 0, method: str = 'cubic') -> numpy.ndarray

   Interpolates a two dimensional array along one axis into n points

   Args:
       array: two dimensional numpy array
       n: number of points to evaluate along the specified axis
       ax: 0 or 1, specifies the axis to interpolate along. 0 corresponds to the rows and 1 corresponds to the columns.
       method: 'linear' or 'cubic'

   Returns:
       Interpolated array. 2D array of shape [array.shape[0], n] if ax==1, or [n, array.shape[1] if ax==0



.. py:function:: rotate_roi(roi: numpy.ndarray) -> numpy.ndarray

   Rotates coordinate array so that most posterior point is at the beginning

   Args:
       roi: two column numpy array of coordinates to rotate

   Returns:
       numpy array of same shape as roi with rotated coordinates



.. py:function:: offset_coordinates(roi: numpy.ndarray, offsets: Union[numpy.ndarray, float], periodic: bool = True) -> numpy.ndarray

   Reads in coordinates, adjusts according to offsets

   Args:
       roi:  two column array containing x and y coordinates. e.g. roi = np.loadtxt(filename)
       offsets: array the same length as coors. Direction?
       periodic: set to True if the ROI is periodic

   Returns:
        array in same format as coors containing new coordinates.

        To save this in a fiji readable format:
        np.savetxt(filename, newcoors, fmt='%.4f', delimiter=' ')



.. py:function:: interp_roi(roi: numpy.ndarray, periodic: bool = True, npoints: Optional[int] = None, gap: int = 1) -> numpy.ndarray

   Interpolates coordinates to one pixel distances (or as close as possible to one pixel). Linear interpolation

   Args:
       roi: two column array containing x and y coordinates. e.g. roi = np.loadtxt(filename)
       periodic: set to True if the ROI is periodic
       npoints: number of points to interpolate to
       gap: alternatively, specify the desired gap between succesive coordinates in pixel units

   Returns:
       interpolated ROI (numpy array)



.. py:function:: interpolate(knots: TensorLike, positions: TensorLike, degree: int, cyclical: bool, name: str = 'bspline_interpolate') -> tensorflow.Tensor

   Applies B-spline interpolation to input control points (knots).
   Note:
     In the following, A1 to An, and B1 to Bk are optional batch dimensions.
   Args:
     knots: A tensor with shape `[B1, ..., Bk, C]` containing knot values, where
       `C` is the number of knots.
     positions: Tensor with shape `[A1, .. An]`. Positions must be between
       `[0, C - D)` for non-cyclical and `[0, C)` for cyclical splines, where `C`
       is the number of knots and `D` is the spline degree.
     degree: An `int` between 0 and 4, or an enumerated constant from the Degree
       class, which is the degree of the splines.
     cyclical: A `bool`, whether the splines are cyclical.
     name: A name for this op. Defaults to "bspline_interpolate".
   Returns:
     A tensor of shape `[A1, ... An, B1, ..., Bk]`, which is the result of spline
     interpolation.


.. py:class:: ImageQuantGradientDescent(img: Union[numpy.ndarray, list], roi: Union[numpy.ndarray, list], sigma: float = 3.5, periodic: bool = True, thickness: int = 50, rol_ave: int = 5, rotate: bool = False, nfits: Union[int, None] = 100, iterations: int = 2, lr: float = 0.01, descent_steps: int = 300, adaptive_sigma: bool = False, batch_norm: bool = False, freedom: float = 10, roi_knots: int = 20, fit_outer: bool = True, zerocap: bool = False, save_training: bool = False, save_sims: bool = False, verbose: bool = True)


   .. py:method:: run()


   .. py:method:: preprocess(frame: numpy.ndarray, roi: numpy.ndarray) -> Tuple[numpy.ndarray, float, numpy.ndarray]

      Preprocesses a single image with roi specified

      Steps:
      - Straighten according to ROI
      - Apply rolling average
      - Either interpolated to a common length (self.nfits) or pad to length of largest image if nfits is not speficied
      - Normalise images, either to themselves or globally



   .. py:method:: init_tensors()

      Initialising offsets, cytoplasmic concentrations and membrane concentrations as zero
      Sigma initialised as user-specified value (or default), and may be trained



   .. py:method:: sim_images() -> Tuple[tensorflow.Tensor, tensorflow.Tensor]

      Simulates images according to current membrane and cytoplasm concentration estimates and offsets



   .. py:method:: losses_full() -> tensorflow.Tensor


   .. py:method:: fit()


   .. py:method:: adjust_roi()

      Can do after a preliminary fit to refine coordinates
      Must refit after doing this



   .. py:method:: plot_losses(log: bool = False)



.. py:function:: create_offsets_spline(offsets_t, roi_knots, periodic, nimages, nfits, roi) -> tensorflow.Tensor


.. py:function:: straighten(img: numpy.ndarray, roi: numpy.ndarray, thickness: int, periodic: bool = True, interp: str = 'cubic', ninterp: Optional[int] = None) -> numpy.ndarray

   Creates straightened image based on coordinates
   Todo: Doesn't work properly for non-periodic rois

   Args:
       img: numpy array of image to straighten
       roi: coordinates of roi (two column array with x and y coordinates), should be 1 pixel length apart in a loop
       thickness: thickness (pixel units) of the region surrounding the ROI to straighten
       periodic: set to True is the ROI is periodic (a full loop)
       interp: interpolation type, 'cubic' or 'linear
       ninterp: optional. If specified, interpolation along the y axis of the straight image will be at this many
       evenly spaced points. If not specified, interpolation will be performed at pixel-width distances.

   Returns:
       Straightened image as 2D numpy array. Will have dimensions [thickness, roi.shape[0]] unless ninterp is
       specified, in which case [ninterp, roi.shape[0]]



.. py:function:: rolling_ave_2d(array: numpy.ndarray, window: int, periodic: bool = True) -> numpy.ndarray

   Returns rolling average across the x axis of a 2D array

   Args:
       array: two dimensional array
       window: rolling average window size
       periodic: specifies if array is periodic. If true, averaging rolls over at ends

   Returns:
       numpy array same size as input array



.. py:function:: interp_1d_array(array: numpy.ndarray, n: int, method: str = 'cubic') -> numpy.ndarray

   Interpolates a one dimensional array into n points

   Args:
       array: one dimensional numpy array
       n: number of points to evaluate. Will evaluate this many points at evenly space intervals along the length of
       array
       method: 'linear' or 'cubic'

   Returns:
       interpolated array (one dimensional array of length n)



.. py:function:: interp_2d_array(array: numpy.ndarray, n: int, ax: int = 0, method: str = 'cubic') -> numpy.ndarray

   Interpolates a two dimensional array along one axis into n points

   Args:
       array: two dimensional numpy array
       n: number of points to evaluate along the specified axis
       ax: 0 or 1, specifies the axis to interpolate along. 0 corresponds to the rows and 1 corresponds to the columns.
       method: 'linear' or 'cubic'

   Returns:
       Interpolated array. 2D array of shape [array.shape[0], n] if ax==1, or [n, array.shape[1] if ax==0



.. py:function:: rotate_roi(roi: numpy.ndarray) -> numpy.ndarray

   Rotates coordinate array so that most posterior point is at the beginning

   Args:
       roi: two column numpy array of coordinates to rotate

   Returns:
       numpy array of same shape as roi with rotated coordinates



.. py:function:: interp_roi(roi: numpy.ndarray, periodic: bool = True, npoints: Optional[int] = None, gap: int = 1) -> numpy.ndarray

   Interpolates coordinates to one pixel distances (or as close as possible to one pixel). Linear interpolation

   Args:
       roi: two column array containing x and y coordinates. e.g. roi = np.loadtxt(filename)
       periodic: set to True if the ROI is periodic
       npoints: number of points to interpolate to
       gap: alternatively, specify the desired gap between succesive coordinates in pixel units

   Returns:
       interpolated ROI (numpy array)



.. py:function:: offset_coordinates(roi: numpy.ndarray, offsets: Union[numpy.ndarray, float], periodic: bool = True) -> numpy.ndarray

   Reads in coordinates, adjusts according to offsets

   Args:
       roi:  two column array containing x and y coordinates. e.g. roi = np.loadtxt(filename)
       offsets: array the same length as coors. Direction?
       periodic: set to True if the ROI is periodic

   Returns:
        array in same format as coors containing new coordinates.

        To save this in a fiji readable format:
        np.savetxt(filename, newcoors, fmt='%.4f', delimiter=' ')



.. py:function:: spline_roi(roi: numpy.ndarray, periodic: bool = True, s: float = 0.0, k: int = 3) -> numpy.ndarray

   Fits a spline to points specifying the coordinates of the cortex, then interpolates to pixel distances

   Args:
       roi: two column array containing x and y coordinates. e.g. roi = np.loadtxt(filename)
       periodic: set to True if the ROI is periodic
       s: splprep s parameter
       k: splprep k parameter (spline order)

   Returns:
       spline ROI (numpy array)



.. py:class:: ImageQuantDifferentialEvolutionSingle(img: Union[numpy.ndarray, list], sigma: float = 2.0, roi: Union[numpy.ndarray, list] = None, freedom: float = 0.5, periodic: bool = True, thickness: int = 50, itp: int = 10, rol_ave: int = 10, parallel: bool = False, cores: Optional[int] = None, rotate: bool = False, zerocap: bool = True, nfits: Optional[int] = None, iterations: int = 2, interp: str = 'cubic', bg_subtract: bool = False)


   Quantification works by taking cross-sections across the membrane, and fitting the resulting profile as the sum of
   a cytoplasmic signal component and a membrane signal component. Differential evolution algorithm

   Input data:
   img                image

   Background curves:
   sigma              if either of above are not specified, assume gaussian/error function with width set by sigma

   ROI:
   roi                coordinates defining cortex. Can use output from def_roi function

   Fitting parameters:
   freedom            amount of freedom allowed in ROI (pixel units)
   periodic           True if coordinates form a closed loop
   thickness          thickness of cross-section over which to perform quantification
   itp                amount to interpolate image prior to segmentation (this many points per pixel in original image)
   rol_ave            width of rolling average
   rotate             if True, will automatically rotate ROI so that the first/last points are at the end of the long
                      axis
   zerocap            if True, prevents negative membane and cytoplasm values
   nfits              performs this many fits at regular intervals around ROI
   iterations         if >1, adjusts ROI and re-fits
   interp             interpolation type (linear or cubic)
   bg_subtract        if True, will estimate and subtract background signal prior to quantification

   Computation:
   parallel           TRUE = perform fitting in parallel
   cores              number of cores to use if parallel is True (if none will use all available)

   Saving:
   save_path          destination to save results, will create if it doesn't already exist



   .. py:method:: run()


   .. py:method:: fit()


   .. py:method:: _fit_profile(profile: numpy.ndarray) -> Tuple[float, float, float]


   .. py:method:: _mse(l_c_m: list, profile: numpy.ndarray) -> numpy.ndarray


   .. py:method:: sim_images()

      Creates simulated images based on fit results



   .. py:method:: adjust_roi()

      Can do after a preliminary fit to refine coordinates
      Must refit after doing this



   .. py:method:: reset()

      Resets entire class to its initial state



   .. py:method:: reset_res()

      Clears results




.. py:class:: ImageQuantDifferentialEvolutionMulti(img: Union[numpy.ndarray, list], roi: Union[numpy.ndarray, list] = None, sigma: float = 2.0, periodic: bool = True, thickness: int = 50, freedom: float = 0.5, itp: int = 10, rol_ave: int = 10, parallel: bool = False, cores: Optional[int] = None, rotate: bool = False, zerocap: bool = True, nfits: Optional[int] = None, iterations: int = 1, interp: str = 'cubic', bg_subtract: bool = False, verbose: bool = True)


   .. py:method:: run()



.. py:function:: gaus(x: numpy.ndarray, centre: float, width: float) -> numpy.ndarray

   Create Gaussian curve with centre and width specified

   Args:
       x: array of input x values
       centre: centre of the Gaussian curve (in x units)
       width: width of the gaussian curve (in x units)

   Returns:
       Gaussian curve



.. py:function:: error_func(x: numpy.ndarray, centre: float, width: float) -> numpy.ndarray

   Create error function with centre and width specified

   Args:
       x: array of input x values
       centre: centre of the error function curve (in x units)
       width: width of the error function curve (in x units)

   Returns:
       error function curve



.. py:function:: polycrop(img: numpy.ndarray, polyline: numpy.ndarray, enlarge: float) -> numpy.ndarray

   Crops image according to polyline coordinates by setting values not contained within the coordinates to zero

   Args:
       img: numpy array of image
       polyline: roi specifying the bounding region (two columns specifying x and y coordinates)
       enlarge: amount by which to expand or contract the ROI (pixel units)

   Returns:
       numpy array of same shape img, with regions outside of polyline set to zero



.. py:function:: bg_subtraction(img: numpy.ndarray, roi: numpy.ndarray, band: tuple = (25, 75)) -> numpy.ndarray

   Subtracts background intensity from an image of a cell. Background intensity calculated as the mean intensity within
   a band surronding the cell (specified by ROI)

   Args:
       img: numpy array of image to subtract background from
       roi: two column numpy array specifying coordinates of the cell boundary
       band: inner and outer distance of the band from the roi

   Returns:
       numpy array of image with background subtracted



.. py:function:: calc_vol(normcoors: numpy.ndarray) -> float


.. py:function:: calc_sa(normcoors: numpy.ndarray) -> float


.. py:function:: save_img(img: numpy.ndarray, direc: str)

   Saves 2D array as .tif file

   Args:
       img: numpy array of the image to save
       direc: file path to save to (including '.tif' extension)



.. py:function:: in_notebook()

   Tests whether python is being run within a notebook

   https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook



.. py:function:: view_stack(frames: Union[list, numpy.ndarray], start_frame: int = 0, end_frame: Optional[int] = None)


.. py:function:: view_stack_jupyter(frames: Union[list, numpy.ndarray], start_frame: int = 0, end_frame: Optional[int] = None)


.. py:function:: plot_fits(target: Union[list, numpy.ndarray], fit_total: Union[list, numpy.ndarray])


.. py:function:: plot_fits_jupyter(target: Union[list, numpy.ndarray], fit: Union[list, numpy.ndarray])


.. py:function:: plot_segmentation(frames: Union[list, numpy.ndarray], rois: Union[list, numpy.ndarray])

   Plot segmentation results

   Args:
       frames: either a numpy array of a 2D image or a list of 2D arrays
       rois: either a single two-column numpy array of ROI coordinates or a list of arrays

   Returns:
       figure and axis



.. py:function:: plot_segmentation_jupyter(frames: Union[list, numpy.ndarray], rois: Union[list, numpy.ndarray])

   Plot segmentation results - use this function in a jupyter notebook environment

   Args:
       frames: either a numpy array of a 2D image or a list of 2D arrays
       rois: either a single two-column numpy array of ROI coordinates or a list of arrays

   Returns:
       figure and axis



.. py:function:: plot_quantification(mems: Union[list, numpy.ndarray])

   Plot quantification results

   Args:
       mems: either a numpy array of membrane concentrations for one image or a list of arrays for multiple images

   Returns:
       figure and axis



.. py:function:: plot_quantification_jupyter(mems: Union[list, numpy.ndarray])

   Plot quantification results - use this function in a jupyter notebook environment

   Args:
       mems: either a numpy array of membrane concentrations for one image or a list of arrays for multiple images

   Returns:
       figure and axis



.. py:class:: ImageQuantGradientDescent(img: Union[numpy.ndarray, list], roi: Union[numpy.ndarray, list], sigma: float = 3.5, periodic: bool = True, thickness: int = 50, rol_ave: int = 5, rotate: bool = False, nfits: Union[int, None] = 100, iterations: int = 2, lr: float = 0.01, descent_steps: int = 300, adaptive_sigma: bool = False, batch_norm: bool = False, freedom: float = 10, roi_knots: int = 20, fit_outer: bool = True, zerocap: bool = False, save_training: bool = False, save_sims: bool = False, verbose: bool = True)


   .. py:method:: run()


   .. py:method:: preprocess(frame: numpy.ndarray, roi: numpy.ndarray) -> Tuple[numpy.ndarray, float, numpy.ndarray]

      Preprocesses a single image with roi specified

      Steps:
      - Straighten according to ROI
      - Apply rolling average
      - Either interpolated to a common length (self.nfits) or pad to length of largest image if nfits is not speficied
      - Normalise images, either to themselves or globally



   .. py:method:: init_tensors()

      Initialising offsets, cytoplasmic concentrations and membrane concentrations as zero
      Sigma initialised as user-specified value (or default), and may be trained



   .. py:method:: sim_images() -> Tuple[tensorflow.Tensor, tensorflow.Tensor]

      Simulates images according to current membrane and cytoplasm concentration estimates and offsets



   .. py:method:: losses_full() -> tensorflow.Tensor


   .. py:method:: fit()


   .. py:method:: adjust_roi()

      Can do after a preliminary fit to refine coordinates
      Must refit after doing this



   .. py:method:: plot_losses(log: bool = False)



.. py:class:: ImageQuantDifferentialEvolutionMulti(img: Union[numpy.ndarray, list], roi: Union[numpy.ndarray, list] = None, sigma: float = 2.0, periodic: bool = True, thickness: int = 50, freedom: float = 0.5, itp: int = 10, rol_ave: int = 10, parallel: bool = False, cores: Optional[int] = None, rotate: bool = False, zerocap: bool = True, nfits: Optional[int] = None, iterations: int = 1, interp: str = 'cubic', bg_subtract: bool = False, verbose: bool = True)


   .. py:method:: run()



.. py:class:: ImageQuant(img: Union[numpy.ndarray, list], roi: Union[numpy.ndarray, list], sigma: float = 3.5, periodic: bool = True, thickness: int = 50, rol_ave: int = 5, rotate: bool = False, nfits: Union[int, None] = 100, iterations: int = 2, lr: float = 0.01, descent_steps: int = 400, adaptive_sigma: bool = False, batch_norm: bool = False, freedom: float = 25, roi_knots: int = 20, fit_outer: bool = True, save_training: bool = False, save_sims: bool = False, method: str = 'GD', itp: int = 10, parallel: bool = False, zerocap: bool = False, cores: Optional[float] = None, bg_subtract: bool = False, interp: str = 'cubic', verbose: bool = True)


   Main class to perform image segmentation

   Instructions:

   1. (Optional) Perform SAIBR on image

   2. Specify rough manual ROI

   3. Initialise class

   4. run()

   5. New ROI coordinates will be found at self.roi

   6. Save quantification results using compile_res() - returns a pandas dataframe

   Args:
       img: numpy array of image or list of numpy arrays
       roi: coordinates defining the cortex (two column numpy array of x and y coordinates at 1-pixel width intervals), or a list of arrays
       roi_knots: number of knots in cubic-spline fit ROI
       freedom: amount by which the roi can move (pixel units)
       sigma: gaussian/error function width (pixels units)
       periodic: True if coordinates form a closed loop
       thickness: thickness of cross section over which to perform quantification (pixel units)
       rol_ave: width of rolling average to apply to images prior to fitting (pixel units)
       rotate: if True, will automatically rotate ROI so that the first/last points are at the end of the long axis
       nfits: performs this many fits at regular intervals around ROI. If none, will fit at pixel-width intervals
       iterations: if >1, adjusts ROI and re-fits
       batch_norm: if True, images will be globally, rather than internally, normalised. Shouldn't affect quantification but is recommended during model optimisation
       fit_outer: if True, will fit the outer portion of each profile to a nonzero value
       method: 'GD' for gradient descent or 'DE' for differential evolution. The former is highly recommended, the latter works but is much slower and no longer maintained
       zerocap: if True, limits output concentrations to positive (or very weakly negative) values
       interp: interpolation type, 'cubic' or 'linear'
       lr: learning rate
       descent_steps: number of gradient descent steps
       adaptive_sigma: if True, sigma will be trained by gradient descent
       verbose: False suppresses onscreen output while model is running (e.g. progress bar)
       parallel: LEGACY (for DE method). If True will run in parallel on number of cores specified. NB Very buggy
       cores:  LEGACY (for DE method). Number of cores to use if parallel is True
       itp: LEGACY (for DE method). Amount of interpolation - allows for subpixel alignment


   .. py:method:: run()

      Performs segmentation/quantification and saves results



   .. py:method:: save(save_path: str, i: Optional[int] = None)

      Save results for a single image to save_path as a series of txt files and tifs
      I'd recommend using compile_res() instead as this will create a single pandas dataframe with all the results

      Args:
          save_path: path to save full results
          i: index of the image to save (if quantifying multiple images in batch)



   .. py:method:: compile_res()

      Compile results to a pandas dataframe

      Returns:
          A pandas dataframe containing quantification results



   .. py:method:: view_frames()

      Opens an interactive widget to view image(s)



   .. py:method:: plot_quantification()

      Opens an interactive widget to plot membrane quantification results



   .. py:method:: plot_fits()

      Opens an interactive widget to plot actual vs fit profiles



   .. py:method:: plot_segmentation()

      Opens an interactive widget to plot segmentation results



   .. py:method:: plot_losses(log: bool = False)

      Plot loss curves (one line for each image)

      Args:
          log: if True, plot the logarithm of losses




.. py:function:: def_roi(stack: Union[numpy.ndarray, list], spline: bool = True, start_frame: int = 0, end_frame: Optional[int] = None, periodic: bool = True, show_fit: bool = True, k: int = 3)

   There are two different methods for drawing ROIs depending on if you're using normal python scripts or Jupyter notebooks.
   This is the one to use if you're using python scripts.

   Instructions:

   - click to lay down points

   - backspace at any time to remove last point

   - press enter to select area (if spline=True will fit spline to points, otherwise will fit straight lines)

   - at this point can press backspace to go back to laying points

   - press enter again to close and return ROI


   Args:
       stack: image (2D or 3D numpy array)
       spline: if True, will fit a spline to the user-defined points
       start_frame: if img is a time series, this is the index of the first frame to show
       end_frame: if img is a time series, this is the index of the last frame to show
       periodic: set to True if drawing a periodic ROI
       show_fit: if True, will show the spline fit (if spline=True)
       k: degree of the spline (e.g. 3 = cubic)

   Returns:
       ROI as a numpy array

       To save this in a fiji readable format:
       np.savetxt(filename, roi, fmt='%.4f', delimiter='       ')



.. py:class:: _ROI(img: Union[numpy.ndarray, list], spline: bool = True, start_frame: int = 0, end_frame: Optional[int] = None, periodic: bool = True, show_fit: bool = True, k: int = 3)


   Instructions:

   - click to lay down points

   - backspace at any time to remove last point

   - press enter to select area (if spline=True will fit spline to points, otherwise will fit straight lines)

   - at this point can press backspace to go back to laying points

   - press enter again to close and return ROI


   :param img: input image
   :param spline: if true, fits spline to inputted coordinates
   :return: cell boundary coordinates

   .. py:method:: run()


   .. py:method:: _draw_frame(i: int)


   .. py:method:: _button_press_callback(event: matplotlib.backend_bases.MouseEvent)


   .. py:method:: _key_press_callback(event: matplotlib.backend_bases.KeyEvent)


   .. py:method:: _display_points()



.. py:class:: ROI_jupyter(img: Union[numpy.ndarray, list], spline: bool = True, start_frame: int = 0, end_frame: Optional[int] = None, periodic: bool = True, show_fit: bool = True, k: int = 3)


   There are two different methods for drawing ROIs depending on if you're using normal python scripts or Jupyter notebooks.
   This is the one to use if you're using Jupyter notebooks.

   Example workflow:

   ### Cell 1:

   r = RoiJupyter(img, periodic=True, spline=True)

   r.run()

   # A window will appear - draw the ROI and click save


   ### Cell 2:

   roi = r.roi

   print(roi.shape)

   # Confirm that the shape is not (0, 0)


   To save this in a fiji readable format:
   np.savetxt(filename, roi, fmt='%.4f', delimiter='   ')

   Args:
       img: image (2D or 3D numpy array)
       spline: if True, will fit a spline to the user-defined points
       start_frame: if img is a time series, this is the index of the first frame to show
       end_frame: if img is a time series, this is the index of the last frame to show
       periodic: set to True if drawing a periodic ROI
       show_fit: if True, will show the spline fit (if spline=True)
       k: degree of the spline (e.g. 3 = cubic)



   .. py:method:: run()


   .. py:method:: _button_press_callback(event: matplotlib.backend_bases.MouseEvent)


   .. py:method:: _undo(_)


   .. py:method:: _save(_)


   .. py:method:: _display_points()


   .. py:method:: _draw_frame(i: int)



.. py:function:: spline_roi(roi: numpy.ndarray, periodic: bool = True, s: float = 0.0, k: int = 3) -> numpy.ndarray

   Fits a spline to points specifying the coordinates of the cortex, then interpolates to pixel distances

   Args:
       roi: two column array containing x and y coordinates. e.g. roi = np.loadtxt(filename)
       periodic: set to True if the ROI is periodic
       s: splprep s parameter
       k: splprep k parameter (spline order)

   Returns:
       spline ROI (numpy array)



.. py:function:: interp_roi(roi: numpy.ndarray, periodic: bool = True, npoints: Optional[int] = None, gap: int = 1) -> numpy.ndarray

   Interpolates coordinates to one pixel distances (or as close as possible to one pixel). Linear interpolation

   Args:
       roi: two column array containing x and y coordinates. e.g. roi = np.loadtxt(filename)
       periodic: set to True if the ROI is periodic
       npoints: number of points to interpolate to
       gap: alternatively, specify the desired gap between succesive coordinates in pixel units

   Returns:
       interpolated ROI (numpy array)



.. py:function:: offset_coordinates(roi: numpy.ndarray, offsets: Union[numpy.ndarray, float], periodic: bool = True) -> numpy.ndarray

   Reads in coordinates, adjusts according to offsets

   Args:
       roi:  two column array containing x and y coordinates. e.g. roi = np.loadtxt(filename)
       offsets: array the same length as coors. Direction?
       periodic: set to True if the ROI is periodic

   Returns:
        array in same format as coors containing new coordinates.

        To save this in a fiji readable format:
        np.savetxt(filename, newcoors, fmt='%.4f', delimiter=' ')



