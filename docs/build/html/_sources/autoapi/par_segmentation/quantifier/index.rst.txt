:py:mod:`par_segmentation.quantifier`
=====================================

.. py:module:: par_segmentation.quantifier


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   par_segmentation.quantifier.ImageQuant




.. py:class:: ImageQuant(img: Union[numpy.ndarray, list], roi: Union[numpy.ndarray, list], sigma: float = 3.5, periodic: bool = True, thickness: int = 50, rol_ave: int = 5, rotate: bool = False, nfits: Union[int, None] = 100, iterations: int = 2, lr: float = 0.01, descent_steps: int = 400, adaptive_sigma: bool = False, batch_norm: bool = False, freedom: float = 25, roi_knots: int = 20, fit_outer: bool = True, save_training: bool = False, save_sims: bool = False, method: str = 'GD', itp: int = 10, parallel: bool = False, zerocap: bool = False, cores: Optional[float] = None, bg_subtract: bool = False, interp: str = 'cubic', verbose: bool = True)


   Main class to perform image segmentation

   Instructions:

   1. (Optional) Perform SAIBR on image

   2. Specify rough manual ROI

   3. Initialise class

   4. run()

   5. New ROI coordinates will be found at self.roi

   6. Save quantification results using compile_res() - returns a pandas dataframe

   Args:
       img: numpy array of image or list of numpy arrays
       roi: coordinates defining the cortex (two column numpy array of x and y coordinates at 1-pixel width intervals), or a list of arrays
       roi_knots: number of knots in cubic-spline fit ROI
       freedom: amount by which the roi can move (pixel units)
       sigma: gaussian/error function width (pixels units)
       periodic: True if coordinates form a closed loop
       thickness: thickness of cross section over which to perform quantification (pixel units)
       rol_ave: width of rolling average to apply to images prior to fitting (pixel units)
       rotate: if True, will automatically rotate ROI so that the first/last points are at the end of the long axis
       nfits: performs this many fits at regular intervals around ROI. If none, will fit at pixel-width intervals
       iterations: if >1, adjusts ROI and re-fits
       batch_norm: if True, images will be globally, rather than internally, normalised. Shouldn't affect quantification but is recommended during model optimisation
       fit_outer: if True, will fit the outer portion of each profile to a nonzero value
       method: 'GD' for gradient descent or 'DE' for differential evolution. The former is highly recommended, the latter works but is much slower and no longer maintained
       zerocap: if True, limits output concentrations to positive (or very weakly negative) values
       interp: interpolation type, 'cubic' or 'linear'
       lr: learning rate
       descent_steps: number of gradient descent steps
       adaptive_sigma: if True, sigma will be trained by gradient descent
       verbose: False suppresses onscreen output while model is running (e.g. progress bar)
       parallel: LEGACY (for DE method). If True will run in parallel on number of cores specified. NB Very buggy
       cores:  LEGACY (for DE method). Number of cores to use if parallel is True
       itp: LEGACY (for DE method). Amount of interpolation - allows for subpixel alignment


   .. py:method:: run()

      Performs segmentation/quantification and saves results



   .. py:method:: save(save_path: str, i: Optional[int] = None)

      Save results for a single image to save_path as a series of txt files and tifs
      I'd recommend using compile_res() instead as this will create a single pandas dataframe with all the results

      Args:
          save_path: path to save full results
          i: index of the image to save (if quantifying multiple images in batch)



   .. py:method:: compile_res()

      Compile results to a pandas dataframe

      Returns:
          A pandas dataframe containing quantification results



   .. py:method:: view_frames()

      Opens an interactive widget to view image(s)



   .. py:method:: plot_quantification()

      Opens an interactive widget to plot membrane quantification results



   .. py:method:: plot_fits()

      Opens an interactive widget to plot actual vs fit profiles



   .. py:method:: plot_segmentation()

      Opens an interactive widget to plot segmentation results



   .. py:method:: plot_losses(log: bool = False)

      Plot loss curves (one line for each image)

      Args:
          log: if True, plot the logarithm of losses




